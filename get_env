#!/bin/bash
# get_env - a program for downloading and managing of distributed dotfiles.
# Copyright (C) 2013 Björn Bohman

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see {http://www.gnu.org/licenses/}.
#

# Refactorded 2013 for git

# TODO: Add silent and quietmode for suppressed output, e.g when run from cron
# TODO: Make "dryrun" download and unpack, but not change any files or create any directories.

# Exit on error
# set -e

# This functions starts the script so all functions don't need to be sourced before exiting.
depends() {
	for app in $@;do
		if ! which $app > /dev/null;then
			echo "Missing program \"$app\""
			exit 1
		fi
	done
}

depends wget logger tput cp rm cat ln unlink diff host mkdir grep egrep sed fold unzip rsync


# Variables in capital are localstuffs, the lowercase regards the remote server

# The script name
MYNAME=$(basename $0)

# The absolute script name, on server, and default name.
myabsolutename=get_env

# Conffile
CONFFILE=~/${MYNAME}.conf

# Colors
RED='\033[0;31m'
BOLD_RED='\033[1;31m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
BLUE='\033[1;34m'
GREEN='\033[1;32m'
END='\033[0m'

# Values for Warnings and Info text
TPUT=$(which tput)
POSITION=$(($($TPUT cols) - 10))
TPRINT="$TPUT hpa $POSITION"
# Colors for Info and Warning texts.
INFO=$YELLOW
WARNING=$RED

FAILEDFILE=$(mktemp /tmp/${MYNAME}.XXXXXX)
downloadDir=$(mktemp -d /tmp/${MYNAME}.XXXXXX)
DEBUG=""
noGet_envUpdate=""
ddate=$(date +'%Y-%m-%dT%H:%M:%S')

###  Functions

# Function to print GNU disclaimer
gnuLicens() {
cat <<EOF

$MYNAME Copyright (C) 2013 Björn Bohman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see [http://www.gnu.org/licenses/].

For more information see: https://github.com/spetzreborn/get_env


EOF
}

# Function for word wrapping
foldit() {
	input="$@"
	maxwidth=$(($(tput cols) - 15))
	dbg "$(eval $input)"
	if [ -z "$DEBUG" ];then
		eval "$input" | fold -s -w $maxwidth
	fi
}

# Function to echo out a coloured bar between sections.
bar() {
	echo -e "${BLUE}*-----------*${END}"
	}

# Function to echo out coloured stars between sections.
stars() {
	echo -e "${BOLD_RED}*************${END}"
	}

# Function to echo out "ok" after a check
ok() {
	$TPRINT; echo -e "${GREEN}[OK]${END}"
	}

# Function to echo out "failed" after a check, and exit
failed() {
	$TPRINT; echo -e "${WARNING}[FAILED]${END}"
	echo -e "${WARNING}$@${END}"
	cat $FAILEDFILE
	dbg "$*" "FAILED FILE:" $(cat $FAILEDFILE)
	exit 1 
	}
	
# Non Critical failed.
ncfailed() {
	$TPRINT; echo -e "${WARNING}[FAILED]${END}"
	if [ -n "$1" ]; then
		foldit echo -e "INFO: $@"
	fi
	}
	
# Debug function
dbg() {
	if [ -n "$DEBUG" ];then
		logger -t $0 DEBUG:: -s " $*"
		echo "$(date) $0 DEBUG:: $*" >>$DEBUGLOG
	fi
	}

# Reports to webbserver
# Takes arguments in:  var0=value0 var1=value1
report() {
	dbg "${FUNCNAME}() was called."
	if [ -n "$reportURL" ];then
		dbg "\$reportUrl is set, try to reporting"
		i=0
		args=$#
		while [ $args -gt $i ];do
			awn="${awn}$1&"
			shift
			((i++))
		done
		doReport='wget "$reportUrl" -q -O /dev/null --post-data "
date=$(date +'%Y-%m-%dT%H:%M:%S')&
hostname=$HOSTNAME&
user=$USER&
get_envGitServer=$get_envGitServer&
get_envGitUser=$get_envGitUser&
get_envRepository=$get_envRepository&
get_envVersion=$get_envVersion&
gitServer=$gitServer&
gitUser=$gitUser&
repository=$repository&
VERSION=$VERSION&
myname=$MYNAME&
L_REPO=$L_REPO&
NEW_FILES=$NEW_FILES&
UPDATED_FILES=$UPDATED_FILES&
CREATED_DIRS=$CREATED_DIRS&
${awn}"'

		echo -n "Reporting to webbserver"
		if eval $doReport; then
			ok
			dbg "Reported to webbserver"
		else
			ncfailed
		fi
	else
		dbg "\$reportUrl is not set, don't  reporting"
	fi
}

# Function for exit due to fatal program error
# Takes argument as string containing error message
errorExit() {
	dbg "${FUNCNAME}() was called, arg: $*"
	echo -e "${WARNING}${MYNAME}: ${1:-"Unknown Error"}${END}" 1>&2
	dbg  "${MYNAME}: ${1:-"Unknown Error"}"
	report "error=$1"
	exit 1
}

# Help menu when invoked with -h
helpMenu() {
cat <<EOF
"Useage: ./$0 arguments"
	options:
	-h	 This helptext
	-r repo  Dir to create and download repo to, default same name as my filename (${MYNAME})
	-d	 Debug - shows whats happening and saves debuglog in the form /tmp/${MYNAME}.debuglog.2013-10-21T10:42:37.XXXXXXXXX
	-l	If debug is used, use this file as debuglog.
	-u  Do not update ${MYNAME} even if newer is found

EOF
	exit 0
}

# Function to download zip from github.
# Arg: server user repository branch filePath
downloadAndUnzip() {
	dbg "${FUNCNAME}() was called, arg: $*"
	local server=$1
	local user=$2
	local repository=$3
	local branch=$4
	local inFile="https://${server}/${user}/${repository}/archive/${branch}.zip"
	local outDir="${downloadDir}/${repository}"
	local outFile="${repository}-${branch}.zip"
	createDir ${downloadDir}/${repository}
	foldit echo -n "Downloading ${inFile}"

	# Download
	if [ -z "$DEBUG" ];then
		if wget ${inFile} -O ${outDir}/${outFile} -q; then
			ok
			dbg "Downloaded ${outFile}"

		else
			failed "Could not download zipfile"
		fi
	else
		if wget ${inFile} -O ${outDir}/${outFile}; then
			ok
			dbg "Downloaded ${outFile}"
		else
			failed "Could not download zipfile"
		fi
	fi
	foldit echo -n "Unzipping ${outFile}"
	# Unzip
	if [ -z "$DEBUG" ];then
		if unzip -o -qq ${outDir}/${outFile} -d ${outDir}; then
			ok
			dbg "Unzipped file"
		else
			failed "Failed to unzip"
		fi
	else
		if unzip -o ${outDir}/${outFile} -d ${outDir}; then
			ok
			dbg "Unzipped file"
		else
			failed "Failed to unzip"
		fi
	fi
	foldit echo -n "Moving files to $L_REPO"
	# rsync to $L_REPO
	if [ -z "$DEBUG" ];then
		if  rsync -aq --delete ${outDir}/${repository}-${branch} ${L_REPO}/${repository}/; then
			ok
			dbg "rsync to $L_REPO"
		else
			failed "Failed to rsync"
		fi
	else
		if  rsync -a --delete ${outDir}/${repository}-${branch} ${L_REPO}/${repository}/; then
			ok
			dbg "rsync to $L_REPO"
		else
			failed "Failed to rsync"
		fi
	fi

}

# Files that shall be copied
# Arg: dir_in_repo dir_to_be_moved_to _files_
copyFiles() {
	dbg "${FUNCNAME}() was called, arg: $*"
	local from_dir=$1
	shift
	local to_dir=$1
	shift
# Test if $to_dir exists
	createDir $to_dir

	for file in $*
	do
# If the destfile exist ...
		if [ -f ${to_dir}/${file} ]; then 
# .. diff it with the source file .. This magic diff ignores comments. Both .vimrc and bash comments.
			if ! diff -q -I '^# .*' -I '^" .*' ${L_REPO}/${repository}/${repository}-${VERSION}/${from_dir}/${file} ${to_dir}/${file} >/dev/null 2>&1; then
# .. And if it is not the same, copy to backup file:
				createDir "${L_REPO}/backup"
				foldit echo -n "Found difference in ${to_dir}/${file}, making backup"
				if [ $(echo $file | cut -c1) == "." ];then
					if cp ${to_dir}/${file} ${L_REPO}/backup/dot.${file}.${ddate}; then
						ok
						dbg "Backed up: ${L_REPO}/backup/${file}.${ddate}"
					else
						ncfailed
					fi
				else
					if cp ${to_dir}/${file} ${L_REPO}/backup/${file}.${ddate}; then
						ok
						dbg "Backed up: ${L_REPO}/backup/${file}.${ddate}"
					else
						ncfailed
					fi
				fi
# .. Copy the new file
				foldit echo -n "Copy new ${to_dir}/$file"
				if cp ${L_REPO}/${repository}/${repository}-${VERSION}/${from_dir}/${file} ${to_dir}/${file}; then
					ok
					dbg "Updated file: ${to_dir}/${file} copied ok"
					UPDATED_FILES="${UPDATED_FILES}${file} "
				else
					failed
				fi
			else
				dbg "${file} are up to date"
			fi
# If the to_file dose not exist, just copy it.
		else
			foldit echo -n "Copy new ${to_dir}/${file}"
			if cp ${L_REPO}/${repository}/${repository}-${VERSION}/${from_dir}/${file} ${to_dir}/${file} >/dev/null 2>&1; then
				ok
				dbg "New file: ${to_dir}/${file} copied ok"
				NEW_FILES="${NEW_FILES}${file} "
			else
				failed
			fi
		fi
	done
}

# Number of variables that is supposed to be in CONFFILE, is used to check if new conffile will be written
genConffile() {
	dbg "${FUNCNAME}() was called, arg: $*"
	CONFFILECONTENT="\
# Where to download new get_env from (should be a github repository)
get_envGitServer=${get_envGitServer:-"github.com"}
# github user
get_envGitUser=${get_envGitUser:-"spetzreborn"}
# github repository
get_envRepository=${get_envRepository:-"get_env"}
# Branch from witch get_env is downloaded from. master or trunk
get_envVersion=${VERSION:-"master"}

# Where to download dotfiles from. (should be a github repository)
gitServer=${gitServer:-"github.com"}
# github user
gitUser=${gitUser:-"spetzreborn"}
# github repository
repository=${repository:-"dotfiles"}
# Branch from witch get_env is downloaded from. master or trunk
VERSION=${VERSION:-"master"}

# Path to local repository
L_REPO=$L_REPO

# If set, report status to this address. (Uses report.php from github.com/spetzreborn/get_env)
#reportUrl=""


# Files to be copied to various dirs. Work like:
# [directory where file lives in repo] [directory where file should go] [files]
FILES2COPY[0]='HOME $HOME .testrc'

# This is an more realistic example
# Files to be copied from [HOME] to [$HOME]
# FILES2COPY[0]='HOME $HOME .bashrc .profile .vimrc .gitconfig'
# Files to be copies from [HOME/vim] to [$HOME/.vim/plugin]
# FILES2COPY[1]='HOME/vim $HOME/.vim/plugin gnupg.vim'
"

	CONFFILEVARIBLES=$(echo "$CONFFILECONTENT" | egrep -c '^[^#]')
}

# Change the values in $CONFFILE
# Arg: variable value
changeConffile() {
	dbg "${FUNCNAME}() was called, arg: $*"
	sed -i "s/\($1 *= *\).*/\1$2/" $CONFFILE
}


writeConffile() {
	dbg "${FUNCNAME}() was called, arg: $*"
	# First time run - print GNU information
	gnuLicens
	bar
	foldit echo -n "Saving default configuration in $CONFFILE"
	if echo "$CONFFILECONTENT" > $CONFFILE;then
		ok
	else
		failed "Could not write $CONFFILE"
	fi
}

# TODO: make createDir take multiple arguments for directories to be created 
# TODO: make createDir able to silently create directories when asked. (arguments)
# Creates a directory
createDir() {
	dbg "${FUNCNAME}() was called, arg: $*"
	DIR=$1
	dbg "Test if $DIR exists"
	if [ ! -d $DIR ];then
		foldit echo -n "Creating directory $DIR"
		if mkdir -p $DIR;then
			dbg "Created $DIR"
			ok
			CREATED_DIRS="${CREATED_DIRS}$DIR "
		else
			failed "Failed to create $DIR"
		fi
	fi
}

# Echo variables to debug
showVariables() {
	dbg "Variables I have: "
	dbg "\$MYNAME: $MYNAME"
	dbg "\$gituser: $gituser"
	dbg "\$gitserver: $gitserver"
	dbg "\$L_REPO: $L_REPO"
	dbg "\$get_envGitServer: $get_envGitServer"
	dbg "\$get_envGitUser: $get_envGitUser"
	dbg "\$get_envRepository: $get_envRepository"
	dbg "\$get_envVersion: $VERSION"
	dbg "\$gitServer: $gitServer"
	dbg "\$gitUser: $gitUser"
	dbg "\$repository: $repository"
	dbg "\$VERSION: $VERSION"
	# Call dbg() for all values in array $FILES2COPY
	i=0
	for array in "${FILES2COPY[@]}";do
		dbg "\$FILE2COPY[$i]: $array"
		((i++))
	done
	dbg "\$DEBUG:$DEBUG"
	dbg "\$DEBUGLOG: $DEBUGLOG"
}

# Test if there was a change in get_env - and is needed to be run again.
# Need absolute name in from file, so it truly can make variable name.
# This diff dose not care about comments.
get_envDiffAndRestart() {
	dbg "${FUNCNAME}() was called."
	get_envDownloaded="${L_REPO}/${get_envRepository}/${get_envRepository}-${get_envVersion}/${myabsolutename}"
	if ! diff -q -I '^# .*'  ~/$MYNAME ${get_envDownloaded} >/dev/null 2>&1; then
		echo -e "" 
		foldit echo -e '${INFO}Found newer	 $MYNAME ${END}'
		if [ -n "$noGet_envUpdate" ]; then
			dbg "\$noGet_envUpdate is set, dont replace or run newer" 
			foldit echo "Do not run newer ${MYNAME}"
		else
			foldit echo -en "Replacing	   $(echo ~)/${MYNAME}"
			if cp ${get_envDownloaded} ~/${MYNAME}; then
				ok
				dbg "Replaced ${MYNAME} with newer successfully."
			else
				failed "Could not copy the file ${myabsolutename} to ${MYNAME}"
			fi
			foldit echo -e '${INFO}Executing new $(echo ~)/${MYNAME}${END}'
			bar
			echo
			echo 
			stars
			echo 
			echo
		# Makes next script start with debug if this instance was started with debug.
			if [ -n "$DEBUG" ];then
				if [ -f "$DEBUGLOG" ];then
					cleanup
					exec ~/${MYNAME} -r "$L_REPO" -d -l "$DEBUGLOG"
				else
					cleanup
					exec ~/${MYNAME} -r "$L_REPO" -d
				fi
			else
				exec ~/${MYNAME} -r "$L_REPO"
			fi
		fi
	fi
}

cleanup() {
# Remove downloaded files and temporary directories
	dbg "${FUNCNAME}() was called, arg: $*"
	rm -rf ${downloadDir}
	dbg "cat $FAILEDFILE: " $(cat $FAILEDFILE)
	
	if [ -f "$FAILEDFILE" ];then
		rm $FAILEDFILE 
		dbg "Removed $FAILEDFILE"
	fi
}

### End of functions


# Make tput work in screen
if [ "$TERM" = "screen" ];then
	TERM=xterm
	dbg "\$TERM was screen, setting it to xterm for running in this script"
fi

while getopts ":hudr:l:" opt; do
	case $opt in
		r)	
		L_REPO=$(readlink -f $OPTARG)
		;;	
		d)
		DEBUG=1
		echo "Debug is set, saving debuglog to: $DEBUGLOG"
		;;
		l)
		DEBUGLOG=$(readlink -f $OPTARG)
		;;
		u)
		noGet_envUpdate="1"
		;;
		h) 
		helpMenu 
		;;	
		\?) 
		echo "Invalid option: -$OPTARG" >&2
		exit 1
		;;	
		:)	
		echo "Option -$OPTARG requires an argument." >&2
		exit 1
		;;	
	esac
done

# Only create a debuglog if there is not one.
if [ -n "$DEBUG" ];then
	if [ -z "$DEBUGLOG" ];then
		DEBUGLOG=$(mktemp /tmp/${MYNAME}.debuglog.${ddate}.XXXXXXXXX)
	fi
fi

dbg "I have started, read variables and functions and are on line:$LINENO"
showVariables

# Check for internet connection
dbg "Checking for internet connection . . ."
INETCON=$(host google.com)
INETERR=$?
dbg "Checked internet connection by 'host google.com' answer:${INETCON}"
if [ "$INETERR" != "0" ];then
	errorExit "No internet connection or none functional dns. Exiting"
fi

# Verify write permissions in homedir
if [ ! -w ~ ];then
	errorExit "Have no write permissions in $(echo ~)"
fi


# If argument -r was not given, set default $L_REPO to absolute path
if [ -z "$L_REPO" ]; then
	L_REPO="$(echo ~/.${MYNAME})"
	dbg 'Setting defult $L_REPO to absolut path: ' "$L_REPO"
fi

# genConffile() must be run before attempting to compare conffiles, but after $L_REPO is set.
genConffile
# Checks if conffile exists and have read and write permissions.
if [ -f "$CONFFILE" ];then
	if [ ! -w "$CONFFILE" ] || [ ! -r "$CONFFILE" ];then
		errorExit "No read or write permissions for $CONFFILE"
	fi
# Sanitize conffile so that only sane line exists. TODO: Only accepted  variables that we want?
	if BadContent=$(egrep -v \
	-e "^([A-Za-z_]+=[A-Za-z0-9/_~. ]+)?$" \
	-e "^#" \
	-e "^FILES2COPY[[][0-9]+[]]='[A-Za-z0-9/_~. ]+'" \
	$CONFFILE);then 
		dbg "$CONFFILE is not sanitized: $BadContent"
		errorExit "$CONFFILE contains bad things: $BadContent"
	fi
# Matches variables in default conffile and conffile. Only counts VARIABLE_NAME=variable. Variables must be set
	if [ "$(egrep -c '^[^#]' $CONFFILE)" -eq "$CONFFILEVARIBLES" ]; then
		dbg "Conffile ($CONFFILE) ok, using it."
	else
# Pre source conffile, to be able to use settings from the old conffile.
		. $CONFFILE
# Regenerate conffile, using sourced values.
		genConffile
		dbg "Pre sourced conffile: $CONFFILE"
		dbg "$CONFFILE has not the same numer of values as built in, overwriting using the values from pre sourced conffile."
# Create conffile
		writeConffile "Found no conffile, created $CONFFILE. Edit this before running $MYNAME again."
	fi
else
	dbg "\$CONFFILE ($CONFFILE) does not exist, creating."
	writeConffile
	errorExit "Created $CONFFILE, before running $MYNAME again, edit $CONFFILE"
fi

# Source conffile.
foldit echo -n "Loading configuration in $CONFFILE"
if . $CONFFILE;then
	ok
	dbg "Sourced conffile: $CONFFILE"
else
	failed "Could not source conffile: $CONFFILE"
fi
showVariables

# Some verbose things
foldit echo ""
foldit echo "Using $L_REPO as repo."
foldit echo "Using version: $VERSION "

# Create $L_REPO directory
createDir $L_REPO

# Download new get_env and repository as zip from github
echo ""
bar

# Download latest get_env
downloadAndUnzip $get_envGitServer $get_envGitUser $get_envRepository $get_envVersion
# Check if downloaded get_env is newer, then replace and restart
get_envDiffAndRestart
# Download repository with files
downloadAndUnzip $gitServer $gitUser $repository $VERSION

# TODO: Move this to conffile
# Creates directories
createDir $HOME/sshfs

# Call copyFiles() for all values in array $FILES2COPY
for array in "${FILES2COPY[@]}";do
	copyFiles $array
done

# Send to debug which files where new or updated
dbg "\$NEW_FILES: $NEW_FILES"
dbg "\$UPDATED_FILES: $UPDATED_FILES"


# Specific host configuration
# TODO: Have non yet.

# Special things for new or updated files:
for file in $NEW_FILES $UPDATED_FILES; do
	case $file in
		 .bashrc)
# There was a change in .bashrc and need to source.
			echo ""
			foldit echo -e '${INFO}Noticed change in $(echo ~)/.bashrc${END}'
			echo ""
			foldit echo -e '${INFO}You need to source .bashrc to get the new functions in this shell${END}'
			foldit echo "eg:  . ~/.bashrc"
			bar
			PROMPT_SOURCE=yes
			;;
		.bashrc.*)
# There was a change in one of .bashrc.{files} and need to source .bashrc 
			if [ -z "$PROMPT_SOURCE" ]; then
				foldit echo ""
				foldit echo -e '${INFO}Noticed change in $(echo ~)/${file}${END}'
				foldit echo ""
				foldit echo -e '${INFO}You need to source .bashrc to get the new functions in this shell${END}'
				foldit echo "eg:  . ~/.bashrc"
				bar
				PROMPT_SOURCE=yes
			fi
		;;
	esac
done

# # Special things for new files:
# for file in $NEW_FILES; do
#	case $file in
#	)
#	;;
#	esac
# done
# 
# # Special things for updated files:
# for file in $UPDATED_FILES; do
#	case $file in
#	)
#	;;
#	esac
# done

if [ -z "$NEW_FILES" ] && [ -z "$UPDATED_FILES" ];then
	foldit echo "No new or changed files."
fi

# Report to webbserver my status
report

# Cleanup
cleanup

# End
dbg "End of script, debuglog saved in $DEBUGLOG"
foldit echo -e '${INFO}The environment is now up to date.${END}'
